#!/usr/bin/env bash
# scripts/inject-rules.sh — Merge LLM-generated rules into <project>/.claude/rules/learned-rules.md
# Usage: inject-rules.sh --project PATH --rules-file PATH [--session-count N] [--dry-run] [--verbose]

# Options:
#   --project PATH      Target project root (absolute path)
#   --rules-file PATH   LLM output file with new rules (Markdown, 4 sections)
#   --session-count N   Number of sessions processed this run (for frontmatter)
#   --dry-run           Print what would change, don't write files
#   --verbose           Print debug info to stderr

set -uo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# ── Defaults ──────────────────────────────────────────────────────────────────
PROJECT_PATH=""
RULES_FILE=""
SESSION_COUNT=0
DRY_RUN=false
VERBOSE=false

# ── Parse CLI args ────────────────────────────────────────────────────────────
while [[ $# -gt 0 ]]; do
  case "$1" in
    --project)       PROJECT_PATH="$2"; shift 2 ;;
    --rules-file)    RULES_FILE="$2";   shift 2 ;;
    --session-count) SESSION_COUNT="$2"; shift 2 ;;
    --dry-run)       DRY_RUN=true;  shift ;;
    --verbose)       VERBOSE=true;  shift ;;
    *)
      echo "Unknown option: $1" >&2
      echo "Usage: inject-rules.sh --project PATH --rules-file PATH [--session-count N] [--dry-run] [--verbose]" >&2
      exit 1
      ;;
  esac
done

# ── Validate ──────────────────────────────────────────────────────────────────
[[ -z "$PROJECT_PATH" ]]  && { echo "Error: --project is required" >&2; exit 1; }
[[ -z "$RULES_FILE" ]]    && { echo "Error: --rules-file is required" >&2; exit 1; }
[[ ! -f "$RULES_FILE" ]]  && { echo "Error: rules file not found: $RULES_FILE" >&2; exit 1; }
[[ ! -s "$RULES_FILE" ]]  && { echo "Warning: rules file is empty, skipping" >&2; exit 0; }

TARGET_DIR="${PROJECT_PATH%/}/.claude/rules"
TARGET_FILE="$TARGET_DIR/learned-rules.md"

# ── Helpers ───────────────────────────────────────────────────────────────────
debug() { [[ "$VERBOSE" == true ]] && echo "[debug] $*" >&2; return 0; }

debug "project: $PROJECT_PATH"
debug "rules-file: $RULES_FILE"
debug "target: $TARGET_FILE"

# ── Write LLM output as complete replacement (LLM already merged existing rules) ──
result=$(python3 - "$TARGET_FILE" "$RULES_FILE" "$SESSION_COUNT" "$DRY_RUN" << 'PYEOF'
import sys, os, datetime

CATEGORIES = [
    "## 错误预防规则",
    "## 代码规范",
    "## 架构模式",
    "## 工具与工作流",
]

def parse_rules_file(path):
    if not os.path.exists(path):
        return {}, {cat: [] for cat in CATEGORIES}
    content = open(path, encoding="utf-8").read()
    lines = content.splitlines()
    frontmatter = {}
    body_start = 0
    if lines and lines[0].strip() == "---":
        end = next((i for i, l in enumerate(lines[1:], 1) if l.strip() == "---"), None)
        if end:
            for line in lines[1:end]:
                if ":" in line and not line.startswith("#"):
                    k, _, v = line.partition(":")
                    frontmatter[k.strip()] = v.strip()
            body_start = end + 1
    sections = {cat: [] for cat in CATEGORIES}
    current_cat = None
    for line in lines[body_start:]:
        stripped = line.strip()
        if stripped in sections:
            current_cat = stripped
        elif current_cat and stripped.startswith("- "):
            sections[current_cat].append(stripped)
    return frontmatter, sections

def write_rules_file(path, frontmatter, sections):
    tmp_path = path + ".tmp"
    with open(tmp_path, "w", encoding="utf-8") as f:
        f.write("---\n")
        f.write("# Auto-generated by claude-evolution. Do not edit manually.\n")
        for k, v in frontmatter.items():
            f.write("{}: {}\n".format(k, v))
        f.write("---\n\n")
        for cat in CATEGORIES:
            f.write("{}\n".format(cat))
            rules = sections.get(cat, [])
            if rules:
                for rule in rules:
                    f.write("{}\n".format(rule))
            else:
                f.write("（暂无相关规则）\n")
            f.write("\n")
    os.replace(tmp_path, path)

target_file       = sys.argv[1]
new_rules_file    = sys.argv[2]
session_count_new = int(sys.argv[3]) if sys.argv[3].isdigit() else 0
dry_run           = sys.argv[4].lower() == "true"

existing_fm, _ = parse_rules_file(target_file)
_, new_sections = parse_rules_file(new_rules_file)

total_rules = sum(len(v) for v in new_sections.values())
if total_rules == 0:
    print("Warning: LLM returned no parseable rules, skipping write to preserve existing rules")
    sys.exit(0)

today     = datetime.date.today().isoformat()
old_count = int(existing_fm.get("session_count", 0))
new_fm    = {"last_updated": today, "session_count": old_count + session_count_new}

if dry_run:
    print("DRY RUN: Would replace rules file with {} rule(s) across {} categories".format(
        total_rules, sum(1 for v in new_sections.values() if v)))
    print("Target: {}".format(target_file))
    for cat in CATEGORIES:
        rules = new_sections.get(cat, [])
        if rules:
            print("\n  {}:".format(cat))
            for r in rules:
                print("    {}".format(r))
    sys.exit(0)

os.makedirs(os.path.dirname(target_file), exist_ok=True)
write_rules_file(target_file, new_fm, new_sections)
print("Rules updated: {} total rules".format(total_rules))
PYEOF
)

exit_code=$?
echo "$result"
exit $exit_code
